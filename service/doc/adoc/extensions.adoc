= Extensions bzw. Erweiterungen und App-Projekte

Es gibt keine Unterscheidung von Extensions und App-Projekten.
Diese werden jetzt über einen Projekt-Typ umgesetzt.

Es muss nur eine spezielles Parent in der POM verwendet werden.
Abhängigkeiten können frei hinzugefügt werden,
wobei mindestens `aero.minova.cas.app` als Abhängigkeit angeben werden muss.
Es dürfen keine weiteren Plugins etc. verwendet werden.

Für Kundenprojekt die ausgeliefert werden,
muss in dem Projekt-Verzeichnis die Datei `this-is-deployed-project.txt` vorhanden sein.
Ist dies nicht der Fall, wird das so gebaute CAS nicht vollständig funktionieren.
Der Inhalt ist egal, da dies nur als Trigger für Maven verwendet wird.
Kundenprojekte mit `this-is-deployed-project.txt` dürfen nicht als Abhängigkeit verwendet werden.

 TODO: Vielleicht eine zusätzliche Parent statt `this-is-deployed-project.txt` verwenden?

```
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <artifactId>cas-customer-build-project</artifactId>
    <version>12.67.1-SNAPSHOT</version>
    <description>Stellt sicher, dass im CAS image nur das verfügbar ist,
        was im CAS-App auch veröffentlicht wurde und nicht Dinge,
        welche durch dessen POM reinkopiert wurde.
        Folglich darf diese POM keine Plugins enthalten.
    </description>
    <parent>
        <groupId>aero.minova</groupId>
        <artifactId>cas.extension.parent</artifactId>
        <version>12.67.1-SNAPSHOT</version>
        <relativePath>../cas.extension.parent</relativePath>
    </parent>
    <dependencies>
        <dependency>
            <groupId>aero.minova</groupId>
            <artifactId>cas.app</artifactId>
            <version>12.67.1-SNAPSHOT</version>
        </dependency>
    </dependencies>
    <scm>
        <connection>scm:git:https://github.com/minova-afis/aero.minova.cas.git</connection>
        <tag>v12.64.0</tag>
    </scm>
</project>
```

== Erweiterungs-Registierung

Hierzu muss bei dem jeweiligen Controller nur die Methode *'registerExtension'* aufgerufen werden.
Hierbei muss darauf geachtet werden, dass keine zwei Extensions mit demselben Namen exisiteren.
In diesem Fall wird eine entsprechenede Exception geworfen.

Alle registierten Erweiterungen werden beim 'Setup' automatisch als Recht mit installiert und können so einfacher an die Rollen vergeben werden.
Denn bevor eine Extension ausgeführt wird, werden die Rollen des Nutzers, der die Anfrage stellt, erst einmal darauf überprüft,
ob das entsprechende Recht für die Extension vorhanden ist.

1. Controller-Klasse im src/main/java des extension-Projektes erstellen und dort je nach Bedarf den SQLViewController, den XSqlProcedureController und/oder den SqlProcedureController eintragen. Hier das @Autowired nicht vergessen.

2. Eine Setup-Methode erstellen, welche mit der @PostConstruct-Annotation gekennziechet ist. Diese muss die *'registerExtension'*-Methode des vorher importierten Controllers aufrufen und damit die Extension mit dem dazugehörigen Keyword registrieren.

3. Wenn in einer Extension etwas geloggt werden muss, wird dies über den CustomLogger gemacht. Welche Methode des Loggers für welchen Fall verwendet werden müssen, wird xref:./logs.adoc#[hier] erklärt.

Die Klasse sollte am Ende ungefähr so aussehen:
----
import org.springframework.web.bind.annotation.RestController;

import aero.minova.cas.CustomLogger;
import aero.minova.cas.controller.SqlProcedureController;
import aero.minova.cas.controller.SqlViewController;

@RestController
public class ExampleController {

	@Autowired
	SqlProcedureController sqlProcedureController;

	@Autowired
	XSqlProcedureController xsqlProcedureController;

	@Autowired
	SqlViewController sqlViewController;

	@Autowired
	CustomLogger customLogger;

	@PostConstruct
	public void setup() {
		// fügt Extension hinzu
		sqlProcedureController.registerExtension("xpcasBeispiel", this::doSomething);
	}

	private ResponseEntity<SqlProcedureResult> doSomething(Table inputTable) {
		customLogger.logUserRequest("Hier wird etwas gemacht!");
		return ResponseEntity//
				.ok()//
				.contentType(MediaType.APPLICATION_JSON)//
				.body(new SqlProcedureResult());
	}
----

== Besonderheiten

* Die Extensions sind selbst dafür verwantwortlich, im Fehlerfall Rollbacks durchzuführen.
* Gibt eine Extension null zurück, so wird die Prozedur/Transaktion zusätzlich als SQL ausgeführt